#ifndef ADC_STAT_H
#define ADC_STAT_H

//-------------------------------------
// Усреднение выборки "скользящим окном"
//-------------------------------------

// Обнулить накопительный массив и переинициализировать все счётчики - начать стат.обработку заново
void ADC_AVG_ResetArray(void);

// Добавить очередной Замер к Выборке (скользящее окно сдвигается на единицу, вытесняя самую раннюю запись)
void ADC_AVG_IncludeSample(const int32_t value);

// Вернуть текущее "среднее арифметическое по выборке", собранное методом "скользящего окна"
int32_t ADC_AVG_GetMovingAverage(void);

// Вернуть максимальное значение, ЗА ВСЁ ВРЕМЯ с последнего "сброса"
int32_t ADC_AVG_GetHistoricalMax(void);

// Вернуть минимальное значение, ЗА ВСЁ ВРЕМЯ с последнего "сброса"
int32_t ADC_AVG_GetHistoricalMin(void);

//-------------------------------------
// Стат.оценка выборки  (тем достовернее, чем больше окно)
//-------------------------------------

void ADC_AVG_CalcArrayStatistics(void); // Рассчитать статистические показатели по Текущей Выборке (долгая процедура)
int32_t ADC_AVG_GetArrayMax(void);      // Получить "максимальное  значение" по Текущей Выборке (расчитанное ранее)
int32_t ADC_AVG_GetArrayMin(void);      // Получить "минимальное   значение" по Текущей Выборке (расчитанное ранее)
int32_t ADC_AVG_GetArrayStdDev(void);   // Получить "Стандартное отклонение" по Текущей Выборке (расчитанное ранее)

// Физический смысл "Стандартного отклонения":
//  истинное значение измеряемой величины лежит в диапазоне [AVG - 2*StdDev .. AVG + 2*StdDev], с вероятностью 95%
//  истинное значение измеряемой величины лежит в диапазоне [AVG - 3*StdDev .. AVG + 3*StdDev], с вероятностью 99.73%

//-------------------------------------
// Калибровка и Конверсия в единицы измерения прикладной величины
//-------------------------------------

// Рассчитать коэффициенты калибровки (и сохранить во внутренние переменные)
void ADC_CNV_RecalculateOffsetCoefficient(int32_t ZeroCode /* Real=0V */);            // 1шаг) замкнуть Щуп на Землю - показания АЦП сунуть сюда...
void ADC_CNV_RecalculateFullscaleCoefficient(int32_t SampleCode, int32_t SampleReal); // 2шаг) подать на Щуп Образцовое напряжение (например 300V) относительно Земли - замер с АЦП и соответствующий эталон в Реальных единицах, сунуть сюда.

// Сохранение/восстановление коэффициентов в энергонезависимой памяти
void ADC_CNV_GetCalibrationCoefficient(int32_t *Offset, int32_t *Fullscale); // Получить значение внутренних переменных, хранящих коэффициенты (с целью сохранения во внешней энергонезависимой памяти, например)
void ADC_CNV_SetCalibrationCoefficient(int32_t Offset, int32_t Fullscale);   // Установить значения внутренних переменных, хранящих коэффициенты (с целью восстановления ранней калибровки при включении устройства, например)

// Конверсия измеренного значения
int32_t ADC_CNV_ConvertCode2Real(int32_t ValueCode); // из кода АЦП в реальные единицы  (предназначена для "абсолютных величин")
int32_t ADC_CNV_ConvertReal2Code(int32_t ValueReal); // из реальных единиц в код АЦП    (предназначена для "абсолютных величин") (Внимание: дает результат пониженной точности!)

int32_t ADC_CNV_ConvertDeltaCode2Real(int32_t DeltaValueCode); // из кода АЦП в реальные единицы (предназначена для "дельта величин")
int32_t ADC_CNV_ConvertDeltaReal2Code(int32_t DeltaValueReal); // из реальных единиц в код АЦП   (предназначена для "дельта величин") (Внимание: дает результат пониженной точности!)

//-------------------------------------
// Служебные методы
//-------------------------------------

// Инициализация модуля (параметры: Offset и Fullscale - значения калибровочных коэффициентов, восстановленные из энергонезависимой памяти)
void ADC_AVG_Init(const int32_t Offset, const int32_t Fullscale);

#endif // ADS1256_H